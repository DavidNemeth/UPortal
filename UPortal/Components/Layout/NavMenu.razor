@using Microsoft.FluentUI.AspNetCore.Components
@using Microsoft.FluentUI.AspNetCore.Components.Icons
@inject IExternalApplicationService ExternalAppService
@inject NavigationManager NavigationManager

<FluentNavMenu Id="main-nav" Collapsible="true" Width="250" Title="Navigation menu" AriaLabel="Main navigation menu">
    <FluentNavLink Href="/" Match="NavLinkMatch.All" Icon="@(new Icons.Regular.Size24.Home())" IconColor="Color.Accent">Home</FluentNavLink>
    <FluentNavGroup Title="Applications" Icon="@(new Icons.Regular.Size24.Apps())" Gap="10px">
        @if (_externalApplications != null)
        {

            @foreach (var app in _externalApplications)
            {
                <FluentNavLink Href="@($"/app/{app.Id}")" Icon="@(GetIconInstance(app.IconName))" IconColor="Color.Accent">
                    @app.AppName
                </FluentNavLink>
            }
        }
    </FluentNavGroup>
    <FluentNavGroup Title="Admin" Icon="@(new Icons.Regular.Size24.PersonAlert())" Gap="10px">
        <FluentNavLink Href="/admin/locations" Icon="@(new Icons.Regular.Size24.Building())" IconColor="Color.Accent">Locations</FluentNavLink>
        <FluentNavLink Href="/admin/machines" Icon="@(new Icons.Regular.Size24.Desktop())" IconColor="Color.Accent">Machines</FluentNavLink>
    </FluentNavGroup>
</FluentNavMenu>


@code {
    private List<ExternalApplicationDto>? _externalApplications;

    protected override async Task OnInitializedAsync()
    {
        await LoadExternalApplicationsAsync();
        // A more robust solution would use a shared service to notify NavMenu of changes.
        // For now, this loads apps when the NavMenu is first initialized.
        // If an app is added/deleted, a page refresh might be needed to see NavMenu updates,
        // or we'd need to implement an eventing system.
    }

    private async Task LoadExternalApplicationsAsync()
    {
        _externalApplications = await ExternalAppService.GetAllAsync();
        StateHasChanged();
    }

    // Helper to get Icon instance - this should be centralized or made consistent
    // This is a simplified version. Ensure it aligns with other components.
    private Icon GetIconInstance(string iconFullName)
    {
        if (string.IsNullOrEmpty(iconFullName)) return new Icons.Regular.Size24.Question();

        return iconFullName switch
        {
            "@Icons.Regular.Size24.Home" => new Icons.Regular.Size24.Home(),
            "@Icons.Regular.Size24.AppFolder" => new Icons.Regular.Size24.AppFolder(),
            "@Icons.Regular.Size24.Link" => new Icons.Regular.Size24.Link(),
            "@Icons.Regular.Size24.Globe" => new Icons.Regular.Size24.Globe(),
            "@Icons.Regular.Size24.Settings" => new Icons.Regular.Size24.Settings(),
            "@Icons.Regular.Size24.Mail" => new Icons.Regular.Size24.Mail(),
            "@Icons.Regular.Size24.CalendarLtr" => new Icons.Regular.Size24.CalendarLtr(),
            "@Icons.Regular.Size24.Document" => new Icons.Regular.Size24.Document(),
            "@Icons.Regular.Size24.Heart" => new Icons.Regular.Size24.Heart(),
            "@Icons.Regular.Size24.Star" => new Icons.Regular.Size24.Star(),
            _ => new Icons.Regular.Size24.Question(), // Default for unknown icons
        };
    }

    // This method could be used if we implement IDisposable and subscribe to a service event
    // public void Dispose() { /* Unsubscribe from service events */ }
}